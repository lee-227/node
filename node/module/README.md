## 模块化

### 优点
- 避免命名冲突(减少命名空间污染)
- 更好的分离, 按需加载
- 更高复用性
- 高可维护性
  
### 介绍模块化的发展历程
- 一阶段：无模块化，简单的将所有的js文件放在一起，文件引入顺序不能出错，缺点：污染全局作用域，要注意变量冲突问题。依赖关系不明显，不利于维护。
   1. 全局function，将不同功能封装成全局函数，污染全局变量，模块成员看不出直接关系
   2. 命名空间，简单对象封装，数据不安全，会被外部修改
   3. IIFE自执行函数，闭包，暴露对外使用的变量
- 二阶段：CommonJS规范，每一个文件就是一个模块，其内部定义的变量时属于这个模块的不会对外暴露不会污染全局变量，核心思想require()引入模块module.exports导出模块。优点：在服务器端完成了js的模块化问题，解决了依赖，全局变量冲突的问题，这是运行在js服务器端的必要条件。缺点：CommonJs是同步加载模块的，只有加载完成才能执行后面的操作。对于浏览器端来说，同步加载模块不适用。
- 三阶段：AMD规范，非同步加载模块，允许回调函数，浏览器端适用。AMD规范的实现代表require.js通过define()定义模块require()加载模块。优点：适合在浏览器环境中异步加载模块，可以并行加载多个模块。缺点：提高了开发成本，不能按需加载，而且必须提前加载所有模块。
- 四阶段：CMD规范，跟require.js很相似，但是加载方式更优秀，可以按需加载。优点：实现了浏览器端的模块化加载，可以按需加载就近依赖。缺点：需要SPM打包，模块的加载逻辑偏重
- 特殊存在：UMD规范，AMD以浏览器为第一原则，异步加载模块。CommonJs以服务端为第一原则，同步加载模块而UMD是一种更通用的格式。UMD实现是先判断是否支持NodeJs模块格式，再判断是否支持AMD，都不存在将模块公布全局。
- 五阶段：ES6模块化（推荐）：官方，使用import导入模块，export导出模块。缺点：目前无法在浏览器端使用需要通过bable将import编译为require才能使用。
- AMD跟CMD的区别：AMD对于依赖的模块提前执行，CMD延迟执行。AMD推崇依赖前置，CMD推崇就近依赖。

### Common Js
- module 属性
  - 任意一个js文件都是模块，可以直接使用 module 属性
  - id：返回模块标识符，一般是绝对路径
  - filename：返回文件模块的绝对路径
  - loaded：布尔值，标识模块是否加载完成
  - parent：调用当前模块的模块
  - children：存放当前模块调用的其他模块
  - exports：返回当前模块需要暴露的内容
  - paths：数组，存放不同目录下的 node_modules 位置
- require 属性
  - 读入并执行一个模块文件
  - resolve：返回模块文件的绝对路径
  - extensions：依据不同后缀名执行解析操作
  - main：返回主模块对象

- 加载流程
  - 路径分析：依据标识符确定模块位置，即文件的绝对路径
    - 路径标识符：直接就是路径
    - 非路径标识符：常用于核心模块，第三方包，通过模块路径查找，从父目录向上边了，到每个目录中的node_modules查找对应模块
  - 文件定位：确定目标模块中具体的文件，及文件类型（后缀名）
    - 按照 .js->.json->.node 补足文件后缀
    - 还没有找到，则按照目录进程处理，查找package.json文件，使用JSON.parse()解析文件
    - 找到 main 属性对应入口文件，如果没有后缀名，则再次按照上述规则不足后缀查找模块
    - main属性提供的路径查找不到，没有 main 属性，没有 package 文件，则使用index作为目标模块的入口文件
  - 编译执行：采用对应的方式完成对于文件的编译执行
    - 创建 module 对象
    - 读取目标文件内容
    - 根据文件类型做对应的处理
    - js文件 将读取的内容包括为一个函数，通过vm.runInThisContext执行，返回 module.export 内容
    - json文件 JSON.parse() 解析后返回解析内容